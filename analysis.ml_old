(* Module Analyse : this module does a static analysis of a Polish program.

It does :
- constants propagation : 
  - in arithmetic operation, replaces the operations on
two numbers by the result
  - also does the obvious simplifications by 0 and 1 :
    - '+ 0 e' -> 'e'
    - '* e 1' -> 'e'
    - '* e 0' -> '0'
    - '/ 0 e' -> '0'

It does NOT take care of overflow -> operations are done on `int` types, without
any checks that the result doesn't overflow.
*)
open Polish
open Eval
open Printf

let simplify_expr e env =
  let rec basic_arithmetic e a op =
     match op, a with
      | Add, 0 | Sub, 0 -> simplify e
      | Mul, 1 -> simplify e
      | Mul, 0 -> Num(0)  
      | _ -> failwith "whatever"
  and div_or_mod e a op first =
    if a = 0 then
      if first then Num(0)
      else Op(op, simplify e, Num(a)) 
    else if a = 1 then simplify e
    else Op(op, Num(a), simplify e)
  and simplify e = match e with
    | Num(n) -> Num(n)
    | Var(n) -> (try NameTable.find n env
                 with Not_found -> Var(n))
    | Op(op, e1, e2) ->
       match e1, e2 with
       | Num(a), Num(b) -> Num((Eval.eval_expr Op(op, e1, e2) env))
       | Num(a), e ->
          match op with
          | Div | Mod -> div_or_mod e a op true
          | op -> basic_arithmetic e a op
       | e, Num(a) ->
          match op with
          | Div | Mod -> div_or_mod e a op false
          | op -> basic_arithmetic e a op     
  in simplify e


let simplify_cond c env =
  let comp, e1, e2 = c in
  let e1 = simplify_expr e1 env in
  let e2 = simplify_expr e2 env in
  match e1, e2 with
  | Num(a), Num(b) -> Eval.eval_cond (e1, comp, e2) env
  | _ -> failwith "can't simplify the condition"


let simplify_if c b b2 env =
  let c2 = simplify_cond c env in
  

let simplify_while c b env = 

;;

               
let rec simplify_block (p:program) env =
  match p with
  | [] -> env
  | (i, Set(n, e))::xs -> simplify_block xs (NameTable.add n (eval_expr e env) env)
  | (i, Print(e))::xs -> simplify_block xs env
  | (i, Read(n))::xs -> simplify_block xs env
  | (i, If(c, b, b2))::xs -> simplify_block (simplify_if c b b2 env)::xs env
  | (i, While(c, b))::xs -> simplify_block (simplify_while c b env)::xs env
and eval_if c b b2 env =
  if eval_cond c env then eval_block b env
  else eval_block b2 env
and eval_while c b env =
  if eval_cond c env then
    let env2 = eval_block b env in
    eval_while c b env2
  else env
   
